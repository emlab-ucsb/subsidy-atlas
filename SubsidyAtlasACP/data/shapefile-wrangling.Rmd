---
title: "Shapefile wrangling for the ACP Atlas of Distant Water Fishing"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(sf)
library(here)
library(rmapshaper)
library(mapview)
library(tidyverse)
library(countrycode)

```

## Introduction

This script details the analysis/wrangling done to create the shapefiles used in the ACP tool. 

## Data

The following shapefiles were downloaded from the sources listed below and used in this analysis. 

From Marineregions.org: 
- Maritime Boundaries: World EEZs (v10, 2018-02-21)
- Marine and land zones: the union of world country boundaries and EEZ's (v2, 2014)

> Flanders Marine Institute (2018). Maritime Boundaries Geodatabase: Maritime Boundaries and Exclusive Economic Zones (200NM), version 10. Available online at http://www.marineregions.org/ https://doi.org/10.14284/312

From naturalearthdata.com: 
- 10m Cultural Vectors: Admin 0 - Details: Map Subunits (version 4.1.0)

*/ ------------------- /*
*/ World EEZ Shapefile /*
*/ ------------------- /*

## Maritime Boundaries: World EEZs (v10, 2018-02-21)

### Preliminary edits

Prior to making the edits detailed below, some edits were done to this shapefile before importing it into R for performance reasons. 

First, we uploaded `eez_v10.shp` to mapshaper.org, and simplified it using the Visvalingam / weighted area method (shape removal prevented). 0.5% of original points were kept, and 2,235 line intersections were repaired. We then exported the resulting file out of mapshaper.org as a shapefile. A copy of this intermediate file can be found in `./data/shapefiles_edit/World_EEZ_v10_20180221_LR/eez_v10.shp`. 

We then imported the modified `eez_v10.shp` into QGIS (version 3.4.7-Madeira) and duplicated the layer. After reprojecting one of the two layers so the total extent of the map was from -360 to 360 degrees, we dissolved all polygons by all attributes. Some manual eliminations had to be made so that polygons with the same attributes did not have small slivers and/or dividing lines between them. We then exported this file out of QGIS as a shapefile. This file can be found in 
`./data/shapefiles_edit/World_EEZ_v10_20180221_LR_-360_360/eez_v10.shp`. 

The final shapefile was outputted with the following CRS: WGS 84 (EPSG:4326).

### Edits

The edits done to this shapefile primarily relate to disputed areas and joint management areas. For the purposes of data analysis and visualization, we wanted to easily be able to attribute these areas to each/all of the states involved in the dispute or responsible for management of the area. 

In order to do this, we duplicate the polygons cooresponding to disputed areas and joint management areas and assign them to all states (2-3 distinct states) involved. 

```{r}
# Load EEZ shapefile
eez_shp <- read_sf(dsn = here::here("SubsidyAtlasACP", "data", "shapefiles_edit", "World_EEZ_v10_20180221_LR_-360_360"), layer = "eez_v10") %>%
  setNames(tolower(names(.))) %>%
  st_transform(crs = 4326)
 
# Some manual edits to correct mistakes
eez_shp$sovereign1[eez_shp$mrgid == 49003] <- "China" # south china sea. listed as an overlapping claim, but with no other territories other than China
eez_shp$iso_ter2[eez_shp$mrgid == 50167] <- "SVN"
eez_shp$territory2[eez_shp$mrgid == 50167] <- "Slovenia"
eez_shp$sovereign2[eez_shp$mrgid == 50167] <- "Slovenia"

# Add iso codes for sovereign states
eez_shp_edit <- eez_shp %>%
   mutate(iso_sov1 = case_when(sovereign1 == "Comores" ~ "COM",
                              sovereign1 == "Micronesia" ~ "FSM",
                              TRUE ~ countrycode(sovereign1, "country.name", "iso3c")),
         iso_sov2 = case_when(sovereign2 == "Comores" ~ "COM",
                              TRUE ~ countrycode(sovereign2, "country.name", "iso3c")),
         iso_sov3 = countrycode(sovereign3, "country.name", "iso3c"))

#mapview::mapview(eez_shp)
```

```{r}
# Filter out disputed areas with multiple territories
eez_disputed <- eez_shp_edit %>%
  dplyr::filter(pol_type == "Overlapping claim") %>%
  mutate(iso_ter_all = case_when(!is.na(iso_ter3) ~ paste(iso_ter1, iso_ter2, iso_ter3, sep = ","),
                                 !is.na(iso_ter2) ~ paste(iso_ter1, iso_ter2, sep = ","),
                                 TRUE ~ iso_ter1))

# Expand                                  
eez_disputed_expand <- eez_disputed %>%
  separate_rows(iso_ter_all, sep = ",") %>%
  mutate(matching_entry = case_when(iso_ter1 == iso_ter_all ~ "1",
                                    iso_ter2 == iso_ter_all ~ "2",
                                    iso_ter3 == iso_ter_all ~ "3")) %>%
  mutate(iso_ter = case_when(matching_entry == "1" ~ iso_ter1,
                             matching_entry == "2" ~ iso_ter2,
                             matching_entry == "3" ~ iso_ter3),
         territory = case_when(matching_entry == "1" ~ territory1,
                             matching_entry == "2" ~ territory2,
                             matching_entry == "3" ~ territory3),
         iso_sov = case_when(matching_entry == "1" ~ iso_sov1,
                             matching_entry == "2" ~ iso_sov2,
                             matching_entry == "3" ~ iso_sov3),
         sovereign = case_when(matching_entry == "1" ~ sovereign1,
                             matching_entry == "2" ~ sovereign2,
                             matching_entry == "3" ~ sovereign3)) %>%
  dplyr::select(cat,
                mrgid,
                geoname,
                pol_type,
                iso_ter,
                territory,
                iso_sov,
                sovereign,
                x_1,
                y_1,
                geometry)
st_geometry(eez_disputed_expand) <- eez_disputed_expand$geometry

```

Starting with disputed areas (termed "overlapping claims" in this data set), we have `r nrow(eez_disputed)` regions. Of those, `r nrow(eez_disputed %>% dplyr::filter(!is.na(iso_ter3)))` involve three parties. We duplicate the polygons for these regions, assigning them to each territory involved in the dispute so we can more easily pull them up later. 

```{r}
# Filter out joint management areas with multiple territories
eez_joint <- eez_shp_edit %>%
  dplyr::filter(pol_type == "Joint regime") %>%
  mutate(iso_ter_all = case_when(!is.na(iso_ter3) ~ paste(iso_ter1, iso_ter2, iso_ter3, sep = ","),
                                 !is.na(iso_ter2) ~ paste(iso_ter1, iso_ter2, sep = ","),
                                 TRUE ~ iso_ter1))

# Expand                                  
eez_joint_expand <- eez_joint %>%
  separate_rows(iso_ter_all, sep = ",") %>%
  mutate(matching_entry = case_when(iso_ter1 == iso_ter_all ~ "1",
                                    iso_ter2 == iso_ter_all ~ "2",
                                    iso_ter3 == iso_ter_all ~ "3")) %>%
  mutate(iso_ter = case_when(matching_entry == "1" ~ iso_ter1,
                             matching_entry == "2" ~ iso_ter2,
                             matching_entry == "3" ~ iso_ter3),
         territory = case_when(matching_entry == "1" ~ territory1,
                             matching_entry == "2" ~ territory2,
                             matching_entry == "3" ~ territory3),
         iso_sov = case_when(matching_entry == "1" ~ iso_sov1,
                             matching_entry == "2" ~ iso_sov2,
                             matching_entry == "3" ~ iso_sov3),
         sovereign = case_when(matching_entry == "1" ~ sovereign1,
                             matching_entry == "2" ~ sovereign2,
                             matching_entry == "3" ~ sovereign3)) %>%
  dplyr::select(cat,
                mrgid,
                geoname,
                pol_type,
                iso_ter,
                territory,
                iso_sov,
                sovereign,
                x_1,
                y_1,
                geometry)
st_geometry(eez_joint_expand) <- eez_joint_expand$geometry

```

Next, we have `r nrow(eez_joint)` joint management areas. All involve two parties. We duplicate the polygons for these regions, assigning them to each territory involved in the dispute so we can more easily pull them up later. 

We then added these polygons back into our main data set so that each polygon is attributed to a single territory (with duplicates)

```{r}
eez_200nm <- eez_shp_edit %>%
  dplyr::filter(pol_type == "200NM") %>%
  dplyr::select(cat,
                mrgid,
                geoname,
                pol_type,
                iso_ter = iso_ter1,
                territory = territory1,
                iso_sov = iso_sov1,
                sovereign = sovereign1,
                x_1,
                y_1,
                geometry)

eez_out <- eez_200nm %>%
  rbind(eez_disputed_expand) %>%
  rbind(eez_joint_expand)

#mapview::mapview(eez_out)

write_sf(eez_out, dsn = here::here("SubsidyAtlasACP", "data", "shapefiles_edit", "World_EEZ_v10_SubsidyAtlasACP"), layer = "eez_v10", driver = "ESRI shapefile")
```

*/ -------------------------------------- /*
*/ 10m World Political Subunits Shapefile /*
*/ -------------------------------------- /*

## 10m World Political Subunits

### Preliminary edits

Prior to making the edits detailed below, some edits were done to this shapefile before importing it into R for performance reasons. 

We imported `ne_10m_admin_0_map_subunits.shp` into QGIS (version 3.4.7-Madeira) and duplicated the layer. After reprojecting one of the two layers so the total extent of the map was from -360 to 360 degrees, we dissolved all polygons by all attributes. Some manual eliminations had to be made so that polygons with the same attributes did not have small slivers and/or dividing lines between them. We then exported this file out of QGIS as a shapefile. This file can be found in 
`./data/shapefiles_edit/ne_10m_admin_0_map_subunits_-360_360/ne_10m_admin_0_map_subunits_-360_360.shp`. 

The final shapefile was outputted with the following CRS: WGS 84 (EPSG:4326).

### Edits

The edits done to this shapefile primarily relate to joining the appropriate subunits back together. 

```{r}
land_map <- read_sf(dsn = here::here("SubsidyAtlasACP", "data", "shapefiles_edit", "ne_10m_admin_0_map_subunits_-360_360"), 
                    layer = "ne_10m_admin_0_map_subunits_-360_360") %>%
  setNames(tolower(names(.))) %>%
  dplyr::select(sovereign = sovereignt,
                sov_iso3 = sov_a3,
                type,
                admin,
                admin_iso3 = adm0_a3,
                geounit,
                geo_iso3 = gu_a3,
                subunit,
                subunit_iso3 = su_a3,
                name,
                name_iso3 = brk_a3,
                admin_note = note_adm0,
                name_note = note_brk,
                geometry) %>%
  arrange(sov_iso3, admin_iso3, geo_iso3) %>%
  mutate(sov_admin_same = ifelse(sovereign == admin, T, F))
```

In general we want to assign polygons to the administering state, with a few exceptions. Those are made manually and include the following: 
- 

```{r}
# First filter out disputed areas
land_map_disputed <- land_map %>%
  dplyr::filter(type == "Indeterminate") %>%
  mutate(type = "Disputed")

# Bajo Nuevo Bank (Petrel Is.) - also claimed by Jamaica, Nicaragua, and the United States
land_map_disputed$sovereign[land_map_disputed$admin_iso3 == "BJN"] <- "Colombia"

# Cyprus buffer zone - In the middle of the turkish/greek 




# First deal with merging the ones for which the sovereign and administering state are the same. These should be easy.
land_map_sovereign <- land_map %>%
  dplyr::filter(sov_admin_same)

not_sovereign <- land_map_sovereign %>%
  dplyr::filter(geo_iso3 %in% c("GLP", "GUF", "MTQ", "MYT", "REU", # french overseas territories
                                "NLY", # caribbean netherlands
                                "BVT", "NJM", "BVT", # norway
                                "RUC")) # crimea
```




```{r}
  left_join(flag_regions, by = c("iso3" = "territory_iso3"))
land_map <- read_sf(dsn = "./data/shapefiles_edit/ne_10m_admin_0_map_subunits_-360_360")
```



## Regional blocks

We also wanted to use the merged land/EEZ boundary shapefile to show the extent of our ACP states by region. The raw shapefiles used to create these was sourced from Marineregions.org (Marine and land zones: the union of world country boundaries and EEZs, Version 2 - 2014). This shapefile was last downloaded on July 31, 2019. We manually changed the extent of this shapefile in QGIS to be from -30 to 330 degrees so all of our ACP EEZs are intact. 

There are a couple of problems with using this this shapefile that need to be corrected for: 
- The Gilbert Islands are assigned to the United States Minor Outlying Islands (instead of Kiribati)
- The Phoenix Islands are assigned to the United States Minor OUtlying Islands (instead of Kiribati) and are still connected to Howland and Baker. 

These corrections were made using Version 10 of the World Maritime Boundaries (World EEZs - 2018) from Marineregions.org.

```{r}
land_eez_shp <- st_read(dsn = here::here("SubsidyAtlasACP", "data", "shapefiles_edit", "EEZ_land_union_v2_201410_-30_360_manualedits"), layer = "EEZ_land_union_v2_201410_-30_330_manualedits") %>%
  setNames(tolower(names(.)))

acp_land_eez_union <- land_eez_shp %>%
  right_join(acp_states, by = c("iso_3digit" = "territory_iso3")) %>%
      group_by(iso_3digit, region, region_specific) %>%
      summarize(geometry = st_union(geometry))

st_write(acp_land_eez_union, dsn = here::here("SubsidyAtlasACP", "data", "shapefiles_edit", "EEZ_land_union_v2_custom_ACP"), layer = "EEZ_land_union_v2_custom_ACP", driver = "ESRI Shapefile", delete_layer = T)

```