---
output:
  html_document: default

title: "Distant Water Fishing Atlas - Global Vessel List"
author: "Kat Millage, Matt Warham"
date: "`r format(Sys.time(), '%B %d, %Y')`"
fontsize: 11pt
---

```{r setup, include=FALSE}
# Chunk options
knitr::opts_chunk$set(echo = TRUE)

# Load packages
library(knitr) 
library(countrycode) # country name matching
library(bigrquery) # access Bigquery from R
#devtools::install_github("r-dbi/bigrquery")
library(tidyverse)

# Path to cleaned subsidies data file (2018)
subsidy_dat_sumaila_path <- here::here("data", "edited", "sumaila_et_al_2019_subsidies_tidy.csv")
subsidy_year <- 2018

# Path to cleaned ssf subsidy data file (2018)
ssf_subsidy_prop_dat_path <- here::here("data", "edited", "schuhbauer_ssf_subsidies_proportions.csv")

### Set run options
# Bigquery project
bq_project <-  "emlab-gcp"
vessel_year <- 2018

### Create results directories
results_dir <- here::here("results/global/02-vessel-list-global/")
  if (dir.exists(results_dir) == F) { dir.create(results_dir, recursive = T) }

# Temporary solution to bigrquery error (August 5, 2020) - see https://github.com/r-dbi/bigrquery/issues/395 for details
options(scipen = 20)
```

# Introduction 

This script creates the global vessel list used in the Distant Water Fishing Atlas toolkit. It requires access to the raw Global Fishing Watch (GFW) data stored on BigQuery (not-publically available), as well as a valid Google Cloud Console billing account. It creates and outputs the raw 2018 global vessel list (`r paste0(results_dir, "vessel_list_2018_raw.csv")`) with effort by vessel aggregated to the EEZ and/or FAO statistical region.  

At this phase, the process of pulling this data is identical to the process used to create the dataset underlying the SubsidyExplorer toolkit. 

# Extract good fishing vessels from existing vessel info table

This section describes the process of linking to the most recent version of the GFW vessel information table, and pulling information on all likely fishing vessels represented in that dataset. This process was last performed on `r format(Sys.time(), '%B %d, %Y')`. 

The vessel info table we're using (`world-fishing-827.gfw_research.vi_ssvid_byyear_v20190430`) has all sorts of stuff in it, so there are some basic filters we need to apply. 

First, we remove all transmissions from objects that are likely fishing gear (buoys, nets, etc.), rather than vessels. 

Second, we apply a number of filters to remove ids associated with non-fishing, inactive, and spoofing vessels:
- MMSI must be on the best fishing vessel list
- MMSI cannot be used by 2+ vessels with different names simultaneously
- MMSI cannot be used by multiple vessels simultaneously for more than 3 days
- MMSI has not been found to be offsetting its position
- MMSI vessel class can be inferred by the neural net (i.e. it is an active vessel)
- MMSI was active for at least 1 day and fished for at least 1 hour in a year
- MMSI is associated with fewer than five shipnames

Finally, GFW has manually compiled a list of vessel IDs that are bad, so we exclude those. 

```{r}
sql <- "WITH
  # This query identifies fishing vessels that meet annual quality criteria
  # e.g. not spoofing/offsetting/too many identities/etc.
  good_fishing_vessels AS (
  SELECT
      ssvid,
      year,
      best.best_vessel_class vessel_class,
      best.best_flag flag_iso3
    FROM
      `world-fishing-827.gfw_research.vi_ssvid_byyear_v20190430`
    WHERE
      on_fishing_list_best # MMSI must be on best fishing list
      AND (activity.overlap_hours_multinames = 0 OR activity.overlap_hours_multinames IS NULL) # MMSI cannot be used by 2+ vessels with different names simultaneously
      AND activity.overlap_hours < 24*3 # MMSI cannot be used by multiple vessels simultaneously for more than 3 days
      AND activity.offsetting IS FALSE # MMSI not offsetting position
      AND inferred.inferred_vessel_class_byyear IS NOT NULL # MMSI vessel class can be inferred by the neural net (active)
      # MMSI active for at least 1 days and fished for at least 1 hours in the year.
      AND activity.fishing_hours > 1
      AND activity.active_hours > 24*1
      AND 5 >= ( # MMSI associated with fewer than five shipnames
        SELECT
          COUNT(*)
        FROM (
          SELECT
            value,
            SUM(count) AS count
          FROM
            UNNEST(ais_identity.n_shipname)
          WHERE
            value IS NOT NULL
          GROUP BY
            value)
        WHERE
          count >= 10)
      AND ssvid NOT IN (
        SELECT
          ssvid
        FROM
          `ucsb-gfw.SubsidyExplorer.likely_gear`)),
          
  # This subquery identifies MMSI that offset a lot
  nast_ssvid AS (
  SELECT
    ssvid,
    SUM( positions) positions
  FROM `world-fishing-827.gfw_research.pipe_v20190502_segs`
  WHERE
    (dist_avg_pos_sat_vessel_km > 3000 AND sat_positions_known > 5)
    AND first_timestamp < timestamp('2018-12-31')
    AND last_timestamp > timestamp('2018-01-01')
  GROUP BY ssvid)

# Filter so manually determined bad mmsi and those ofsetting a lot are excluded and return
SELECT
  ssvid,
  year,
  vessel_class,
  flag_iso3
FROM
  good_fishing_vessels
WHERE
  CAST(ssvid AS int64) NOT IN (
    SELECT
      ssvid
    FROM
      `world-fishing-827.gfw_research.bad_mmsi`
    CROSS JOIN
      UNNEST(ssvid) AS ssvid)
  AND ssvid NOT IN (SELECT ssvid FROM nast_ssvid)"

fv_table <- bq_table(project = bq_project, 
                     table = "all_good_fishing_vessels",
                     dataset = "distant_water_fishing_atlas")

if(bq_table_exists(fv_table)){
  
  bq_table_delete(fv_table)
  bq_project_query(bq_project, 
                   sql, 
                   destination_table = fv_table, 
                   use_legacy_sql = FALSE, 
                   allowLargeResults = TRUE)
  
}else {
  bq_table_create(fv_table)
  bq_project_query(bq_project, 
                   query = sql, 
                   destination_table = fv_table,
                   use_legacy_sql = FALSE, 
                   allowLargeResults = TRUE)
}
```

## Effort By EEZ and/or FAO region

We then extract the number of hours spent fishing by each of our good fishing vessels in different EEZs and/or FAO regions from the raw fishing effort table (`world-fishing-827.gfw_research.pipe_v20190502_fishing`).

To identify valid fishing effort, we apply the following filters:
- The fishing activity must have occured during a valid segment as identified by GFW.
- The fishing activity must have occured during a segment with more than 10 positions that was not concurrently overlapping with another, longer, segment for the same MMSI.  
- The vessel performing the fishing activity must appear on the list of good fishing vessels created above

We then extract a vessel table with the the following attributes: 
- year (int): Year. Matches our data year specified above.
- eez_id (chr): EEZ identifier. 
- eez_territory1_iso3 (chr) : Three letter code cooresponding to the administering territory of the EEZ
- eez_territory2_iso3 (chr) : Three letter code cooresponding to the second administering territory of the EEZ (disputed and/or joint regime areas only)
- eez_territory3_iso3 (chr) : Three letter code cooresponding to the third administering territory of the EEZ (disputed and/or joint regime areas only)
- eez_sovereign1_iso3 (chr) : Three letter code cooresponding to the sovereign state of the EEZ
- eez_sovereign2_iso3 (chr) : Three letter code cooresponding to the second sovereign state of the EEZ (disputed and/or joint regime areas only)
- eez_sovereign3_iso3 (chr) : Three letter code cooresponding to the third sovereign state of the EEZ (disputed and/or joint regime areas only)
- is_territorial (bln): Did the fishing activity occur within 12nm of shore? (This is an approximation of a country's territorial waters)
- fao_region (int): Major FAO statistical region
- ssvid (chr): Unique vessel identification number given by GFW (MMSI number for most vessels)
- flag_iso3 (chr): Best flag state of the vessel. 
- vessel_class (chr): Best vessel type. 
- length_m (dbl): Best vessel length in meters.
- tonnage_gt (dbl): Best vessel tonnage in gross tons. 
- engine_power_kw (dbl): Best engine power in killowatt hours. 
- broadcast_shipname (chr): Most common ship name broadcast by the vessel.
- broadcast_callsign (chr): Most common ship callsign broadcast by the vessel.
- broadcast_imo (chr): Most common imo number broadcast by the vessel.
- fishing_hours_eez_fao_ter: Total annual fishing hours in the specified eez and/or FAO statistical region and/or territorial seas by the vessel
- fishing_KWh_eez_fao_ter: Total annual fishing KWh hours in the specified eez and/or FAO statistical region and/or territorial seas by the vessel

```{r}
sql3 <- paste0('
WITH
  # This subquery identifies good segments
  good_segments AS (
  SELECT
    seg_id
  FROM
    `world-fishing-827.gfw_research.pipe_v20190502_segs`
  WHERE
    good_seg
    AND positions > 10
    AND NOT overlapping_and_short),
  
  # This subquery identifies good fishing vessels from our previous query
  good_vessels AS (
  SELECT
    *
  FROM
    `emlab-gcp.SubsidyExplorer.all_good_fishing_vessels`),
    
  # This subquery identifies vessel information that we want to keep
  vessel_info AS (
  SELECT
    ssvid,
    year,
    best.best_flag as flag_iso3,
    best.best_vessel_class as vessel_class,
    best.best_length_m as length_m,
    best.best_tonnage_gt as tonnage_gt,
    best.best_engine_power_kw as engine_power_kw,
    ais_identity.n_shipname_mostcommon.value as broadcast_shipname,
    ais_identity.n_callsign_mostcommon.value as broadcast_callsign,
    ais_identity.n_imo_mostcommon.value as broadcast_imo
  FROM
    `world-fishing-827.gfw_research.vi_ssvid_byyear_v20190430`
  WHERE
    year =', vessel_year, '),
    
  # This subquery identifies eez information that we want to keep
  eez_info AS (
  SELECT
    CAST(eez_id as string) as eez_id,
    territory1_iso3 as eez_territory1_iso3,
    territory2_iso3 as eez_territory2_iso3,
    territory3_iso3 as eez_territory3_iso3,
    sovereign1_iso3 as eez_sovereign1_iso3,
    sovereign2_iso3 as eez_sovereign2_iso3,
    sovereign3_iso3 as eez_sovereign3_iso3
  FROM
    `world-fishing-827.gfw_research.eez_info`),
  
  # This subquery gets all fishing effort by ssvid, eez, and fao region in 2018 cooresponding to good segments and good vessels
  fishing_by_eez_and_fao AS (
    SELECT
      EXTRACT(year FROM date) AS year,
      ssvid,
      if(ARRAY_LENGTH(regions.eez)=0, "0000", regions.eez[ordinal(1)]) AS eez_id,
      if(distance_from_shore_m <= 22224, TRUE, FALSE) AS is_territorial,
      if(ARRAY_LENGTH(regions.major_fao)=0, "0", regions.major_fao[ordinal(1)]) AS fao_region,
      sum(hours) AS fishing_hours_eez_fao_ter
    FROM
      `world-fishing-827.gfw_research.pipe_v20190502_fishing`
    WHERE
      date > timestamp("', vessel_year, '-01-01")
      AND date < timestamp("', vessel_year, '-12-31")
      AND ARRAY_LENGTH(regions.major_fao) > 0 # removes fishing inland
      AND nnet_score2 > .5
      AND seg_id IN (
        SELECT
          seg_id
        FROM
          good_segments)
      AND ssvid IN (
        SELECT
          ssvid
        FROM
          good_vessels
        WHERE
          year = ', vessel_year, ')
    GROUP BY
      year,
      ssvid,
      eez_id,
      is_territorial,
      fao_region
    ORDER BY
      year,
      ssvid,
      fishing_hours_eez_fao_ter DESC)
        
SELECT
  *,
  CASE
    WHEN engine_power_kw IS NULL THEN fishing_hours_eez_fao_ter*400
    ELSE fishing_hours_eez_fao_ter*engine_power_kw
  END AS fishing_KWh_eez_fao_ter
FROM
  fishing_by_eez_and_fao
LEFT JOIN
  vessel_info
USING
  (ssvid,
  year)
LEFT JOIN
  eez_info
USING
  (eez_id)')

eez_effort_table <- bq_table(project = bq_project, 
                     table = paste0("effort_eez_fao_ter_good_fishing_vessels_", vessel_year, "_raw"),
                     dataset = "distant_water_fishing_atlas")

if(bq_table_exists(eez_effort_table)){
  
  bq_table_delete(eez_effort_table)
  effort_good_fishing_vessels_eez <- 
    bq_project_query(bq_project, 
                    query = sql3, 
                    destination_table = eez_effort_table, 
                    use_legacy_sql = FALSE, 
                    allowLargeResults = TRUE) %>%
     bq_table_download()
  
}else {
  bq_table_create(eez_effort_table)
  effort_good_fishing_vessels_eez <- 
    bq_project_query(bq_project, 
                   query = sql3, 
                   destination_table = eez_effort_table,
                   use_legacy_sql = FALSE, 
                   allowLargeResults = TRUE) %>%
    bq_table_download()
}

# Save locally
eez_effort_table_local <- paste0(results_dir, "effort_eez_fao_ter_good_fishing_vessels_", vessel_year, "_raw.csv")

if(file.exists(eez_effort_table_local)){
  unlink(eez_effort_table_local)
  write_csv(effort_good_fishing_vessels_eez, eez_effort_table_local)
}else{
  write_csv(effort_good_fishing_vessels_eez, eez_effort_table_local)
}
```

# Correct outdated flag codes and Identify EU and USA dependent vessels

Before allocating catches and subsidies across vessels, we need to do some manual corrections for incorrect flag codes and we need to identify vessels flagged to states that are overseas dependencies of the EU or USA. We assume that these vessels recieve subsidies from their sovereign states. 

```{r}
# Load country dependencies helper file
country_dependencies <- read_csv(here::here("data", "lookup-tables", "country_dependencies.csv")) %>%
  dplyr::select(flag_iso3 = iso3, flag_sovereign_iso3 = sovereign_iso3, is_EU, is_dependency = is_overseas_territory)

```

```{r}
# Get table of all flag states in the data to check for weird flag codes
gfw_flags <- effort_good_fishing_vessels_eez %>%
  distinct(flag_iso3) %>%
  mutate(flag_name = countrycode(flag_iso3, "iso3c", "country.name")) %>%
  arrange(flag_iso3)

# Only three we need to fix: GCA (outdated code for Guatemala), ROM (outdated code for Romania), and UNK (unknown, for some reason not just NA)
vessel_list <- effort_good_fishing_vessels_eez
vessel_list$flag_iso3[vessel_list$flag_iso3 == "GCA"] <- "GTM"
vessel_list$flag_iso3[vessel_list$flag_iso3 == "ROM"] <- "ROU"
vessel_list$flag_iso3[vessel_list$flag_iso3 == "UNK"] <- NA
```

# Allocating Subsidies

Before we allocate subsidies, we need to get total fishing kWh by flag. 

```{r}
# Effort by flag
effort_flag <- vessel_list %>%
  group_by(flag_iso3) %>%
  summarize(fishing_KWh = sum(fishing_KWh_eez_fao_ter, na.rm = T)) %>%
  ungroup()
```

The process for allocating subsidies is slightly more straightforard as we only have data by flag. 

Let's first assign sovereigns to all of our flags
```{r}
# Now lets add sovereign flags
vessel_list <- vessel_list %>%
  left_join(country_dependencies, by = c("flag_iso3" = "flag_iso3"))

# And manually correct two - Clipperton Atoll and Western Sahara
vessel_list$flag_iso3[vessel_list$flag_iso3 == "CPT"] <- "FRA"
vessel_list$flag_iso3[vessel_list$flag_iso3 == "ESH"] <- "MAR"
```


```{r}
# Load subsidy data
subsidies_dat <- read_csv(subsidy_dat_sumaila_path) %>%
  dplyr::filter(year == subsidy_year)

# Load proportions going to SSF, and remove
subsidies_dat_lsf <- read_csv(ssf_subsidy_prop_dat_path) %>%
  dplyr::select(-source) %>%
  left_join(subsidies_dat, by = c("iso3", "category", "category_name", "type", "type_name")) %>%
  mutate(value_lsf = value*(1-prop_ssf))

# Summarize total subsidies by type and flag
subsidies_flag <- subsidies_dat_lsf %>%
  group_by(iso3, type) %>%
  summarize(value = sum(value_lsf, na.rm = T)) %>%
  spread(type, value)

subsidy_types <- unique(subsidies_dat$type)
good_subsidy_types <- c("A1", "A2", "A3")
ugly_subsidy_types <- c("C1", "C2", "C3")
bad_subsidy_types <- c("B1", "B2", "B3", "B4", "B5", "B6", "B7")

# Resummarize effort including overseas territories with their sovereign
effort_sovereign_flag <- vessel_list %>%
  group_by(flag_sovereign_iso3) %>%
  summarize(fishing_KWh = sum(fishing_KWh_eez_fao_ter, na.rm = T)) %>%
  ungroup()
                          
# Calculate subsidy rates by flag
subsidy_rates_flag <- effort_sovereign_flag %>%
  inner_join(subsidies_flag, by = c("flag_sovereign_iso3" = "iso3")) %>%
  group_by(flag_sovereign_iso3) %>%
  summarize_at(subsidy_types, list(per_fishing_KWh = ~./fishing_KWh))
subsidy_rates_flag[is.na(subsidy_rates_flag)] <- 0

# Save subsidy rates by flag to Bigquery
subsidy_rates_table <- bq_table(project = bq_project, 
                                table = "subsidy_rates_flag_sov", 
                                dataset = "distant_water_fishing_atlas")

  # Check if that table already exists. If not, create it. Otherwise clear it. 
  if(bq_table_exists(subsidy_rates_table)){
    
    subsidy_rates_table %>%
      bq_table_delete() 
    
    subsidy_rates_table %>%
      bq_table_create() %>%
      bq_table_upload(values = subsidy_rates_flag, 
                      fields = subsidy_rates_flag)
    
  }else{
    subsidy_rates_table %>%
      bq_table_create() %>%
      bq_table_upload(values = subsidy_rates_flag, 
                      fields = subsidy_rates_flag)
      
  }

# Join back to vessel_list
vessel_list <- vessel_list %>%
  left_join(subsidy_rates_flag, by = c("flag_sovereign_iso3"))
```

Now we can calculate total subsidies by type for each vessel

```{r}
rename_me <- function(x){
  str_replace(x, "_per_fishing_KWh", "")
}

vessel_list_out <- vessel_list %>%
  mutate_at(paste0(subsidy_types, "_per_fishing_KWh"), list(subs = ~.*fishing_KWh_eez_fao_ter)) %>%
  rename_at(paste0(subsidy_types, "_per_fishing_KWh_subs"), rename_me) %>%
  dplyr::select_at(vars(-contains("_per_fishing_KWh"))) %>%
  mutate(good_subs = rowSums(select(., one_of(paste0(good_subsidy_types, "_subs")))),
         bad_subs = rowSums(select(., one_of(paste0(bad_subsidy_types, "_subs")))),
         ugly_subs = rowSums(select(., one_of(paste0(ugly_subsidy_types, "_subs")))))

write_csv(vessel_list_out, paste0(results_dir, "vessel_list_2018_raw.csv"))
```
